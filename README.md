## Introduction

The main goal of this project is to show off my SQL skills in data analysis. 

The dataset used in the analysis shown below combines all the information from an ecommerce company's online transactions. Here is a visual representation of the database's schema : 

![Database Schema](/assets/schema_picture.png)

**Data Source :** [OLTP : Ecommerce data - Kaggle](https://www.kaggle.com/datasets/sharangkulkarni/oltp-ecommerce-data?select=supplier.csv)

**SQL Queries :** [sql_project Folder](/sql_project/)

**AI Note :** This project has been created with the help of ChatGPT, namely for the generation of the vizualization used below and for the production of the texts for this markdown file.

## Questions to Investigate

In order to make the best use of all the data extracted, the analysis will be structured around the following 5 questions :   

1. **Who are the top-10 customers ?**
2. **What are the top-selling categories of product ?**
3. **What are the products most likely returned ?**
4. **What are the suppliers most likely to disappoint ?**
5. **Are the marketing campaigns boosting the number of orders placed ?**

## Tools I used

For my deep dive into the ecommerce dataset, I leveraged the power of several key tools :

- **SQL :** The programming language allowing me to query the database.
- **MySQL Workbench :** The chosen database management system, mainly used to create and load the various tables.
- **Visual Studio Code :** Used for executing the SQL queries.
- **Git & GitHub :** Essential for sharing my SQL scripts and keeping track of the various versions.

## The Analysis

Detailed investigation of the 5 questions mentioned previously : 

### 1. Top-10 customers

To identify the top customers of the company, there are actually two options possible given this dataset. We can indeed retrieve the best clients either by : 

1. The number of orders placed
2. The total amount spent

Let's investigate the two methods and compare the results!

#### 1.1 Top-10 customers by orders placed

The following query has been used to identify the top clients in terms of orders placed :

```sql
SELECT
    CONCAT(first_name, ' ', last_name) AS full_name,
    COUNT(DISTINCT order_id) AS nb_of_orders
FROM orders
LEFT JOIN customer ON orders.customer_id = customer.customer_id
GROUP BY customer.customer_id
ORDER BY nb_of_orders DESC
LIMIT 10;
```
Here are the results using the first method : 

| Full Name           | Number of Orders |
|---------------------|------------------|
| Carolyn Russell      | 133              |
| Travis May           | 131              |
| Carolyn Harrison     | 130              |
| Julian Lawrence      | 127              |
| Deanna Harris        | 124              |
| Dana Johnson         | 123              |
| Randall Sanchez      | 123              |
| John Robinson        | 122              |
| Patricia Livingston  | 122              |
| Cynthia Adkins       | 120              |

#### 1.2 Top-10 customers by amount spent

A very similar query has been used for this other alternative, except that we are now also comparing the results of the top-10 clients with the global average amount spent. For your information, the average amount is **1,563,053**.

```sql
SELECT 
    CONCAT(first_name, ' ', last_name) AS full_name,
    SUM(amount) AS total_amount,
    ROUND((SUM(amount)/(AVG(SUM(amount)) OVER ()) - 1) * 100, 2) AS comparison_to_avg
FROM orders
LEFT JOIN customer ON orders.customer_id = customer.customer_id
GROUP BY customer.customer_id
ORDER BY total_amount DESC
LIMIT 10;
```

Here are the resutls for this second method : 

| Full Name          | Total Amount | Comparison to Avg (%) |
|--------------------|--------------|------------------------|
| Deanna Harris       | 2,184,326    | 39.75                  |
| Carolyn Russell     | 2,117,907    | 35.50                  |
| Eric George         | 2,108,996    | 34.93                  |
| John Robinson       | 2,066,850    | 32.23                  |
| Travis May          | 2,062,195    | 31.93                  |
| Regina Klein        | 2,010,304    | 28.61                  |
| Brandy Pierce       | 2,002,197    | 28.10                  |
| Bethany Mayer       | 1,991,089    | 27.38                  |
| Tammy Hale          | 1,976,402    | 26.44                  |
| Allison Williams    | 1,973,399    | 26.25                  |

Despite some customers being present in both top 10s, we can notice that the results are relatively different depending on the method used. 

### 2. Top-selling categories of products

For this second question, we are now looking at the products sold. Instead of looking at indiviual products  *(in terms of items sold or in terms of customer reviews, similarly to what we did for the customers)*, we will check the percentages of total sales generated by each category 
of products in order to find the top-selling categories.

But first, we want to identify possible non-selling products using the following query :

```sql
SELECT name
FROM product
WHERE product_id NOT IN
    (SELECT DISTINCT product_id
     FROM order_item);
```

No results were returned from the query above meaning that each product of the company has been sold at least once. 

Now, let's look at the top-selling categories using the following code : 

```sql
SELECT
    category_name,
    SUM(subtotal)/SUM(SUM(subtotal)) OVER() AS perc_of_total_sales
FROM product
LEFT JOIN order_item on product.product_id = order_item.product_id
LEFT JOIN subcategory on product.subcategory_id = subcategory. subcategory_id
LEFT JOIN category on subcategory.category_id = category.category_ID
GROUP BY category_name
ORDER BY perc_of_total_sales DESC;
```

The results are displayed in the pie chart below : 

![Query 2 Results](/assets/products_categories.png)
*Pie chart displaying the percentages of total sales per products category, this graph has been generated by ChatGPT*

Although 'Electronics' appears to be the top-selling category, we can notice from the graph shown above that there are no major differences between the differents categories and that the total sales are well spread accross all of them. 

### 3. Products most likely returned

The query below helps us identifying the products most likely to be returned : 

```sql
SELECT 
    name AS product_name,
    SUM(CASE WHEN return_id IS NULL THEN 0 ELSE quantity END) AS qty_returned,
    SUM(quantity) AS qty_sold,
    SUM(CASE WHEN return_id IS NULL THEN 0 ELSE quantity END)/SUM(quantity) AS perc_returned
FROM order_item
LEFT JOIN returns ON order_item.order_id = returns.order_id AND order_item.product_id = returns.product_id
LEFT JOIN product ON order_item.product_id = product.product_id
GROUP BY name
ORDER BY perc_returned DESC;
```

It's important to note that this relies on the following assumption : **without any further information, we assume that, when there is a return, the full quantity is returned.** 

By checking the first 10 elements listed below, we can notice that no product stands out with a particularly high return rate and that the return rate does not exceed 3%.

| Product Name                   | Quantity Returned | Quantity Sold | Percentage Returned |
|---------------------------------|-------------------|---------------|---------------------|
| Analog Watches - Product 3      | 80                | 3,149         | 2.54%               |
| Medical Supplies - Product 3    | 71                | 2,997         | 2.37%               |
| Action Figures - Product 4      | 72                | 3,037         | 2.37%               |
| Running Shoes - Product 4       | 70                | 3,009         | 2.33%               |
| Car Accessories - Product 1     | 67                | 2,946         | 2.27%               |
| Skincare - Product 1            | 61                | 2,735         | 2.23%               |
| Canned Goods - Product 1        | 62                | 2,850         | 2.18%               |
| Camping Gear - Product 3        | 68                | 3,152         | 2.16%               |
| Home Security - Product 3       | 68                | 3,193         | 2.13%               |
| Haircare - Product 5            | 62                | 3,016         | 2.06%               |

### 4. Suppliers most likely to disappoint

Following on from the products most likely returned, we now turn our attention to the suppliers most likely to disappoint.  By this we mean the suppliers most likely to send a defective order.

First, we want to define was it a defective order. In order to do that, we'll retrieve all the possible reasons justifying a return to then identify the reasons for which the supplier is liable. 

```sql
SELECT DISTINCT reason
FROM returns;
```

| Return Reason                    |
|-----------------------------------|
| Received wrong product            |
| Color doesn't match               |
| Changed my mind                   |
| Item not as described             |
| Product didn't meet expectations  |
| Size doesn't fit                  |
| Defective product                 |
| Found a better deal               |
| Ordered by mistake                |
| Product damaged during shipping   |

Amongst the reasons listed above, we can identify the followings as the ones for which the supplier might be held responsible *(assuming that he takes care of the packaging)*: 

- Received wrong product
- Color doesn't match
- Item not as described
- Product didn't meet expectations
- Defective product

We can now identify the suppliers most likely to disappoint with the following query : 

```sql
WITH defective_orders_id AS (
    SELECT DISTINCT order_id
    FROM returns
    WHERE reason IN ("Received wrong product", "Color doesn't match", "Item not as described", "Product didn't meet expecations", "Defective product")
)

SELECT
    supplier_name,
    COUNT(DISTINCT defective_orders_id.order_id) AS defective_orders,
    COUNT(DISTINCT order_item.order_id) AS total_orders,
    COUNT(DISTINCT defective_orders_id.order_id)/COUNT(DISTINCT order_item.order_id) AS perc_defective_orders
FROM order_item
LEFT JOIN defective_orders_id ON defective_orders_id.order_id = order_item.order_id
LEFT JOIN supplier ON order_item.supplier_id = supplier.supplier_id
GROUP BY supplier_name
ORDER BY perc_defective_orders DESC;
```

Here are the 10 suppliers most likely to disappoint : 

| Supplier Name               | Defective Orders | Total Orders | Percentage Defective Orders |
|-----------------------------|------------------|--------------|-----------------------------|
| Freeman-Contreras            | 123              | 5,245        | 2.35%                       |
| Cline, Torres and Poole      | 120              | 5,193        | 2.31%                       |
| House, Price and Casey       | 115              | 5,181        | 2.22%                       |
| Gonzales Group               | 108              | 5,113        | 2.11%                       |
| Phillips and Sons            | 109              | 5,155        | 2.11%                       |
| Ruiz-Booker                  | 108              | 5,138        | 2.10%                       |
| Lee-Smith                    | 107              | 5,099        | 2.10%                       |
| Bautista Inc                 | 107              | 5,147        | 2.08%                       |
| Best, Werner and Clark       | 107              | 5,188        | 2.06%                       |
| Thornton Inc                 | 107              | 5,213        | 2.05%                       |

As for the most returned products, we can again notice that, although they are the most likely to disappoint, there is no supplier which really stands out with a particularly high percentage of defective orders sent.

### 5. Impact of marketing campaigns on orders

Finally, for this last question, we want to investigate the impact of marketing campaigns on the number of orders placed during the specific weeks they are set up.

Again, in order to do that, we have two options : 

- Use the 'offer_week' field of the 'marketing_campaigns' table
- Or check the 'discount' field of the 'order_item' table to identify the weeks during which a discount was effectively applied.

First, we'll create a temporary table listing the weeks per year during which a discount was applied in order to first compare it with the theoretical values displayed in the 'marketing_campaigns' table and then choose which option to use. 

```sql
CREATE TEMPORARY TABLE discounted_weeks (
    SELECT
        YEAR(order_date) AS year,
        WEEK(order_date) AS week,
        discount AS discount
    FROM 
        (SELECT
            order_date,
            CASE WHEN discount > 0 THEN 'Yes' ELSE 'No' END AS discount
        FROM order_item
        LEFT JOIN orders ON order_item.order_id = orders.order_id) AS date_discount
    WHERE discount = 'Yes'
    GROUP BY 1,2,3
); 
```
Unfortunately, by comparing the effective discounted weeks to the theoretical ones with the help of the two queries below, we can notice some discrepencies between theory and reality. Indeed, the code below reveals that discounts were applied accross more weeks in practice that it should have according to the 'marketing_campaigns' table. It's namely due to the discrepency between theoritical weeks of the year and the 'WEEK' component extracted by SQL from the 'order_date', which starts by 0 for some years.

```sql
-- Retrieving weeks in 'discounted_weeks' table not in 'marketing_campaings' table
SELECT *
FROM discounted_weeks
LEFT JOIN marketing_campaigns ON discounted_weeks.week = marketing_campaigns.offer_week
WHERE marketing_campaigns.offer_week IS NULL;

-- Retrieving weeks in 'marketing_campaings' table not in 'discounted_weeks' table
SELECT *
FROM discounted_weeks
RIGHT JOIN marketing_campaigns ON discounted_weeks.week = marketing_campaigns.offer_week
WHERE discounted_weeks.week IS NULL;
```
With these findings, we need to slightly change our approach and look at the impact of discounts on the numbers of orders placed **per day rather than per week** using the effective data. 

The following query gives us the average number of orders placed during discounted days vs normal days :

```sql
WITH discounted_days AS (
    SELECT
        DATE(order_date) AS order_date,
        CASE WHEN discount > 0 THEN 'Yes' ELSE 'No' END AS discount
    FROM order_item
    LEFT JOIN orders ON order_item.order_id = orders.order_id
    WHERE discount > 0
    GROUP BY 1,2)

SELECT
    discount,
    AVG(count_orders) AS avg_orders
FROM 
    (SELECT 
        DATE(orders.order_date) AS order_date,
        CASE WHEN discounted_days.discount = 'Yes' THEN 'Yes' ELSE 'No' END AS discount,
        COUNT(DISTINCT order_id) AS count_orders
    FROM orders
    LEFT JOIN discounted_days ON DATE(orders.order_date) = discounted_days.order_date
    GROUP BY 1,2
    ORDER BY count_orders DESC) AS orders_by_discounted_days
GROUP BY discount;
```

| Discount Applied | Average Orders |
|------------------|----------------|
| No               | 19.6451        |
| Yes              | 19.3547        |

With slight changes in the above code, we can also check the 10 days with the most orders placed in the dataset :

| Order Date  | Discount Applied | Count of Orders |
|-------------|------------------|-----------------|
| 2022-07-26  | No               | 36              |
| 2021-01-16  | No               | 33              |
| 2016-06-18  | Yes              | 33              |
| 2020-05-03  | No               | 33              |
| 2020-04-30  | No               | 33              |
| 2022-08-10  | No               | 33              |
| 2021-02-02  | Yes              | 33              |
| 2019-01-02  | Yes              | 32              |
| 2017-06-30  | No               | 32              |
| 2018-11-11  | No               | 32              |

Surprisingly enough, we notice given the two tables above that the company's marketing campaigns do not seem to be boosting the numbers of orders placed on the relevant days. In the opposite, we can see a majority of 'normal' days in the top-10 days in terms of orders placed and an average slightly higher during non-discounted days.

## Conclusions

As already mentined in the beginning of this README, the main goal of this project is to showcase my data analysis skills using SQL. 

Indeed, although we were able to investigate all the questions mentioned previously through SQL queries, the insights that emerged from them do not suggest a realistic situation. The fact that total sales are almost equally distributed across the different products categories, that no product or supplier really stands out in terms of return rates and that marketing campaigns have no impact on orders placed, all leave us feeling counter-intuitive.